// src/tests/4_createUtilTest.js
const { validateWithJest } = require('../validators/jestValidator');
const { validateTypeScript } = require("../validators/tsValidator"); // For initial linting of generated test code
const fs = require('fs');
const path = require('path');

const id = 'jest-util-test';
const description = 'Creates a comprehensive Jest test set for a utility function and checks coverage.';

// Define the path to the code that the LLM-generated tests will target.
const codeToTestFilePath = path.resolve(__dirname, "../test-assets/staticDebounce.ts");
const codeToTest = fs.readFileSync(codeToTestFilePath, "utf-8");

const prompt = `
You are a senior software engineer specializing in testing.
Given the following TypeScript utility function (from ./staticDebounce.ts), create a comprehensive Jest test suite for it in a single file.
Please output the code in a single code block, surrounded by triple backticks.

Your tests must:
1. Use the Arrange-Act-Assert (AAA) pattern.
2. Follow the F.I.R.S.T principles.
3. Include test cases for basic functionality, multiple rapid calls, calls with arguments, and \`this\` context if applicable.
4. Use 'describe' to group the tests for the 'debounce' function.
5. Import the 'debounce' function from "./staticDebounce" (this will be the name of the file after being copied to a temporary directory for testing).
6. Do not include any text other than the test code itself.

The function to test is:
\`\`\`typescript
${codeToTest}
\`\`\`
`;

/**
 * @param {string} generatedTestCode - The test code generated by the LLM.
 * @returns {Promise<{success: boolean, message: string, details?: string}>}
 */
async function validate(generatedTestCode) {
  // Step 1: Validate the generated test code itself for basic TypeScript correctness.
  const tsValidation = validateTypeScript(generatedTestCode, { isJsx: false }); // Assuming test code is not JSX for debounce
  if (!tsValidation.success) {
    return {
      success: false,
      message: "Generated test code is not valid TypeScript.",
      details: tsValidation.message,
    };
  }

  // Step 2: Run the generated tests against the static debounce function.
  // The `validateWithJest` function now returns coverage information.
  // Pass `false` for isReactCode for utility function tests
  const jestResult = await validateWithJest(generatedTestCode, codeToTest, false);

  // Step 3: Interpret Jest results, including coverage.
  // First, check for critical errors from Jest execution itself
  if (jestResult.message.includes("A critical error occurred during Jest execution") || jestResult.message.includes("Jest test suite failed to run due to a critical error")) {
    return {
      success: false,
      message: `The generated test file failed to run or caused a Jest error: ${jestResult.message}`,
      details: jestResult.details || jestResult.message,
    };
  }

  // If generated tests did not pass against the static code, the LLM failed to generate correct tests.
  if (!jestResult.success) {
    return {
      success: false,
      message: "Generated Jest tests failed to pass against the static code. " + jestResult.message, // jestResult.message here contains details of failed tests
      details: jestResult.details // This might be undefined, jestResult.message is more comprehensive from jestValidator for failures
    };
  }

  // If generated tests passed, then check coverage.
  const MIN_COVERAGE_PCT = 80;
  if (jestResult.coverage && jestResult.coverage.lines && jestResult.coverage.lines.pct !== undefined) {
    if (jestResult.coverage.lines.pct < MIN_COVERAGE_PCT) {
      return {
        success: false,
        message: `Generated tests passed, but line coverage (${jestResult.coverage.lines.pct}%) is below threshold (${MIN_COVERAGE_PCT}%).`,
        details: jestResult.message // Original Jest success message (e.g., "All N tests passed! Coverage: X% lines.")
      };
    } else {
      return {
        success: true,
        message: `Generated tests passed with sufficient line coverage (${jestResult.coverage.lines.pct}%).`,
        details: jestResult.message // Original Jest success message
      };
    }
  } else {
    // This case should ideally not be reached if Jest ran successfully (jestResult.success was true) and coverage was configured.
    return {
      success: false,
      message: "Generated tests passed, but coverage data is missing or incomplete. This may indicate an issue with the test runner or coverage configuration.",
      details: jestResult.message // Original Jest success message
    };
  }
}

module.exports = { id, description, prompt, validate };