// src/tests/2_createTsMock.js
const { validateTypeScript } = require("../validators/tsValidator");
const vm = require("vm");

const id = "ts-mock-from-interface_complex";
const description =
  "Creates an array of 10 mock data objects from existing TypeScript interfaces.";

// The context that the LLM needs and the validator needs.
const interfaceDefinitions = `
interface Profile {
  avatarUrl?: string;
  bio?: string;
}

interface User {
  id: string;
  email: string;
  registrationDate: Date;
  profile: Profile;
  username?: string;
}
`;

const prompt = `
Given the following TypeScript interfaces, create a single mock array named 'mockUsers' of 10 instances of
type 'User[]'. Fill the fields with realistic but fake data. The 'registrationDate' should be a new Date object.
Include optional fields ('username', 'avatarUrl', 'bio') in every second object. Please do not use any external libraries like faker.js.
Only output the full code of 'mockUsers' constant, with no other text or explanations. Please output the code
in a single code block, surrounded by triple backticks.

Interfaces:
${interfaceDefinitions}
`;

/**
 * @param {string} code - The code generated by the LLM.
 * @returns {Promise<{success: boolean, message: string}>}
 */
async function validate(code) {
  // 1. First, check if the generated code is valid TypeScript.
  // We provide the interface definitions as context for the validator.
  const tsValidation = validateTypeScript(code, {
    context: interfaceDefinitions,
  });
  if (!tsValidation.success) {
    return tsValidation;
  }

  // 2. Programmatically execute the code to test the output array.
  // We use Node's `vm` module to run the code in a secure, isolated sandbox.
  try {
    const sandbox = { module: { exports: {} }, Date: Date };
    // We must transpile the TS to JS before executing it.
    const jsCode = require("typescript").transpile(code);

    // The context includes the sandbox and a 'require' function if needed.
    const context = vm.createContext(sandbox);

    // Run the transpiled JavaScript code in the sandbox.
    vm.runInContext(jsCode, context);

    const { mockUsers } = context;

    // 3. Perform a series of checks on the resulting 'mockUsers' array.
    if (!mockUsers) {
      return {
        success: false,
        message: "Generated code did not produce a 'mockUsers' constant.",
      };
    }
    if (!Array.isArray(mockUsers)) {
      return { success: false, message: "'mockUsers' is not an array." };
    }
    if (mockUsers.length !== 10) {
      return {
        success: false,
        message: `Array length is ${mockUsers.length}, but expected 10.`,
      };
    }

    let optionalFieldsCount = 0;
    for (let i = 0; i < mockUsers.length; i++) {
      const user = mockUsers[i];

      // Check required fields on all objects
      if (typeof user.id !== "string" || user.id.length === 0) {
        return {
          success: false,
          message: `User at index ${i} is missing a valid 'id'.`,
        };
      }
      if (typeof user.email !== "string" || !user.email.includes("@")) {
        return {
          success: false,
          message: `User at index ${i} is missing a valid 'email'.`,
        };
      }
      if (!(user.registrationDate instanceof Date)) {
        return {
          success: false,
          message: `User at index ${i} has an invalid 'registrationDate'.`,
        };
      }
      if (typeof user.profile !== "object" || user.profile === null) {
        return {
          success: false,
          message: `User at index ${i} is missing the 'profile' object.`,
        };
      }

      // Check for optional fields based on index
      const hasOptionalUsername =
        "username" in user && typeof user.username === "string";
      const hasOptionalAvatar =
        "avatarUrl" in user.profile &&
        typeof user.profile.avatarUrl === "string";
      const hasOptionalBio =
        "bio" in user.profile && typeof user.profile.avatarUrl === "string";

      if (hasOptionalUsername) optionalFieldsCount++;
      if (hasOptionalAvatar) optionalFieldsCount++;
      if (hasOptionalBio) optionalFieldsCount++;

      // if (i % 2 !== 0) { // Odd indices (1, 3, 5...) are "every second object"
      //     if (!hasOptionalUsername || !hasOptionalAvatar) {
      //         return { success: false, message: `User at odd index ${i} is missing required optional fields ('username', 'avatarUrl').` };
      //     }
      //     optionalFieldsCount++;
      // } else { // Even indices (0, 2, 4...)
      //     if (hasOptionalUsername || hasOptionalAvatar) {
      //         return { success: false, message: `User at even index ${i} unexpectedly contains optional fields.` };
      //     }
      // }
    }

    if (optionalFieldsCount !== 15) {
      return {
        success: false,
        message: `Expected 15 optional fields, but found ${optionalFieldsCount}.`,
      };
    }

    return {
      success: true,
      message:
        "Generated array has 10 valid users and correctly handles optional fields.",
    };
  } catch (error) {
    return {
      success: false,
      message: `An error occurred during code execution or validation: ${error.message}`,
    };
  }
}

module.exports = { id, description, prompt, validate };
