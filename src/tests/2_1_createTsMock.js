// src/tests/2_createTsMock.js
const ts = require('typescript'); // Ensure ts is imported
const { validateTypeScript } = require("../validators/tsValidator");
const vm = require("vm");

const id = "ts-mock-from-interface_complex";
const description =
  "Creates an array of 10 mock data objects from existing TypeScript interfaces.";

// The context that the LLM needs and the validator needs.
const interfaceDefinitions = `
interface Profile {
  avatarUrl?: string;
  bio?: string;
}

interface User {
  id: string;
  email: string;
  registrationDate: Date;
  profile: Profile;
  username?: string;
}
`;

const prompt = `
Given the following TypeScript interfaces, create a single mock array named 'mockUsers' of 10 instances of
type 'User[]'. Fill the fields with realistic but fake data. The 'registrationDate' should be a new Date object.
Include optional fields ('username', 'avatarUrl', 'bio') in every second object. Please do not use any external libraries like faker.js.
Only output the full code of 'mockUsers' constant, with no other text or explanations. Please output the code
in a single code block, surrounded by triple backticks.

Interfaces:
${interfaceDefinitions}
`;

/**
 * @param {string} code - The code generated by the LLM.
 * @returns {Promise<{success: boolean, message: string}>}
 */
async function validate(code) {
  // 1. First, check if the generated code is valid TypeScript and get AST
  const astValidationResult = validateTypeScript(code, {
    context: interfaceDefinitions,
    includeAst: true,
  });

  if (!astValidationResult.success || !astValidationResult.ast) {
    return {
        success: astValidationResult.success,
        message: astValidationResult.ast ? astValidationResult.message : "AST could not be generated."
    };
  }

  const { ast } = astValidationResult;
  let mockUsersVarFound = false;
  let correctTypeAnnotation = false;
  let correctInitializer = false;
  let variableStatementCount = 0;

  ts.forEachChild(ast, node => {
    if (node.kind === ts.SyntaxKind.VariableStatement) {
      variableStatementCount++;
      ts.forEachChild(node.declarationList, varDeclaration => {
        if (varDeclaration.kind === ts.SyntaxKind.VariableDeclaration) {
          if (varDeclaration.name.getText(ast) === 'mockUsers') {
            mockUsersVarFound = true;
            if (varDeclaration.type && varDeclaration.type.kind === ts.SyntaxKind.ArrayType &&
                varDeclaration.type.elementType && varDeclaration.type.elementType.typeName &&
                varDeclaration.type.elementType.typeName.getText(ast) === 'User') {
              correctTypeAnnotation = true;
            }
            if (varDeclaration.initializer && varDeclaration.initializer.kind === ts.SyntaxKind.ArrayLiteralExpression) {
              correctInitializer = true;
            }
          }
        }
      });
    }
  });

  if (!mockUsersVarFound) {
    return { success: false, message: "AST validation: Variable 'mockUsers' not found." };
  }
  if (!correctTypeAnnotation) {
    return { success: false, message: "AST validation: 'mockUsers' is not typed as 'User[]'." };
  }
  if (!correctInitializer) {
    return { success: false, message: "AST validation: 'mockUsers' is not initialized with an array literal." };
  }
  if (variableStatementCount > 1) {
    return { success: false, message: `AST validation: Expected a single variable declaration for 'mockUsers', but found ${variableStatementCount}.`};
  }

  // If AST checks pass, proceed to the existing vm.runInContext validation
  // 2. Programmatically execute the code to test the output array.
  try {
    const sandbox = { module: { exports: {} }, Date: Date };
    // Use the outputText from the initial validation which contains the transpiled JS
    const jsCode = astValidationResult.outputText;

    const context = vm.createContext(sandbox);
    vm.runInContext(jsCode, context);

    const { mockUsers } = context; // This is the executed JS variable

    // 3. Perform a series of checks on the resulting 'mockUsers' array.
    if (!mockUsers) {
      return {
        success: false,
        message: "Generated code did not produce a 'mockUsers' constant after execution.",
      };
    }
    if (!Array.isArray(mockUsers)) {
      return { success: false, message: "'mockUsers' is not an array after execution." };
    }
    if (mockUsers.length !== 10) {
      return {
        success: false,
        message: `Array length is ${mockUsers.length} after execution, but expected 10.`,
      };
    }

    let optionalFieldsCount = 0;
    for (let i = 0; i < mockUsers.length; i++) {
      const user = mockUsers[i];

      if (typeof user.id !== "string" || user.id.length === 0) {
        return {
          success: false,
          message: `User at index ${i} is missing a valid 'id'.`,
        };
      }
      if (typeof user.email !== "string" || !user.email.includes("@")) {
        return {
          success: false,
          message: `User at index ${i} is missing a valid 'email'.`,
        };
      }
      if (!(user.registrationDate instanceof Date)) {
        return {
          success: false,
          message: `User at index ${i} has an invalid 'registrationDate'.`,
        };
      }
      if (typeof user.profile !== "object" || user.profile === null) {
        return {
          success: false,
          message: `User at index ${i} is missing the 'profile' object.`,
        };
      }

      const hasOptionalUsername = "username" in user && typeof user.username === "string";
      const hasOptionalAvatar = "avatarUrl" in user.profile && typeof user.profile.avatarUrl === "string";
      // Bug Fix from original: check bio in user.profile, not user.profile.avatarUrl
      const hasOptionalBio = "bio" in user.profile && typeof user.profile.bio === "string";


      if (i % 2 !== 0) { // Odd indices (1, 3, 5...) are "every second object" as per prompt (clarified from original)
          if (hasOptionalUsername) optionalFieldsCount++;
          if (hasOptionalAvatar) optionalFieldsCount++;
          if (hasOptionalBio) optionalFieldsCount++;
      }
    }
    // The prompt implies optional fields are *only* on every second object.
    // 10 objects total. 5 objects are "every second" (index 1, 3, 5, 7, 9).
    // Each of these 5 objects should have 3 optional fields. So 5 * 3 = 15.
    if (optionalFieldsCount !== 15) {
      return {
        success: false,
        message: `Expected 15 optional fields in total on every second object, but found ${optionalFieldsCount}.`,
      };
    }

    return {
      success: true,
      message:
        "Generated array has 10 valid users and correctly handles optional fields according to AST and runtime checks.",
    };
  } catch (error) {
    return {
      success: false,
      message: `An error occurred during code execution or validation: ${error.message}`,
    };
  }
}

module.exports = { id, description, prompt, validate, interfaceDefinitions }; // ensure interfaceDefinitions is exported
