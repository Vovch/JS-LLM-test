// src/tests/3_createUtilFunction.js
const { validateTypeScript } = require("../validators/tsValidator");
const ts = require("typescript"); // Import the typescript package
const { performance } = require("perf_hooks");

const id = "create-util-function";
const description =
  "Creates a generic debounce utility function in TypeScript.";

const prompt = `
Create a generic TypeScript utility function named 'debounce'. Please include an export for that function but do not include any imports in the final code block.
Please output the code in a single code block, surrounded by triple backticks.

Requirements:
1. It should accept two arguments: 'func' (the function to debounce) and 'delay' (a number in milliseconds).
2. It should be a generic function that preserves the type of 'func'. The signature should look like: \`<T extends (...args: any[]) => any>\`.
3. It should return a new function that, when invoked, will only call 'func' after 'delay' milliseconds have passed without any new calls.
4. Use modern JavaScript (timers, etc.).
5. Export the function.
6. Return only the code for the function, no other text.
`;

/**
 * @param {string} code - The code generated by the LLM.
 * @returns {Promise<{success: boolean, message: string}>}
 */
async function validate(code) {
  // Step 1: Check if the code is valid TypeScript. This is still a valuable first pass.
  const tsValidation = validateTypeScript(code);
  if (!tsValidation.success) {
    return tsValidation;
  }

  // Step 2: Behavioral test. Does the generated function actually debounce?
  try {
    // --- FIX: Transpile the TypeScript code to JavaScript before executing it. ---
    const jsCode = ts.transpileModule(code, {
      compilerOptions: { module: ts.ModuleKind.CommonJS },
    }).outputText;

    // We use `eval` here in a controlled way to get the exported function.
    // A more complex setup could use `vm` but for this util, eval is sufficient.
    const tempModule = { exports: {} };
    // We pass our temp module to the executed code.
    const funcWrapper = new Function("exports", jsCode);
    funcWrapper(tempModule.exports);

    // The exported debounce function should now be on tempModule.exports.
    const debounce =
      tempModule.exports.debounce || Object.values(tempModule.exports)[0];

    if (typeof debounce !== "function") {
      return {
        success: false,
        message:
          'The generated code does not export a function named "debounce".',
      };
    }

    let callCount = 0;
    const mockFn = () => {
      callCount++;
    };

    const debouncedFn = debounce(mockFn, 50);

    debouncedFn();
    debouncedFn();
    debouncedFn(); // Call 3 times in quick succession

    // At this point, the function should not have been called yet.
    if (callCount !== 0) {
      return {
        success: false,
        message: "Function was called immediately, not debounced.",
      };
    }

    // Wait for the debounce delay to pass
    await new Promise((resolve) => setTimeout(resolve, 100));

    if (callCount !== 1) {
      return {
        success: false,
        message: `Function was called ${callCount} times, but expected 1.`,
      };
    }

    return { success: true, message: "Debounce function behaved as expected." };
  } catch (error) {
    return {
      success: false,
      message: `An error occurred during behavioral test: ${error.message}`,
    };
  }
}

module.exports = { id, description, prompt, validate };
