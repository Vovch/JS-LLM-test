// src/tests/3_createUtilFunction.js
const { validateTypeScript } = require("../validators/tsValidator");
const { runJestAgainstGeneratedCode } = require("../validators/generatedCodeJestValidator");
const path = require("path");
const ts = require("typescript"); // Still needed for AST functions

const id = "create-util-function";
const description =
  "Creates a generic debounce utility function in TypeScript.";

const prompt = `
Create a generic TypeScript utility function named 'debounce'. Please include an export for that function but do not include any imports in the final code block.
Please output the code in a single code block, surrounded by triple backticks.

Requirements:
1. It should accept two arguments: 'func' (the function to debounce) and 'delay' (a number in milliseconds).
2. It should be a generic function that preserves the type of 'func'. The signature should look like: \`<T extends (...args: any[]) => any>\`.
3. It should return a new function that, when invoked, will only call 'func' after 'delay' milliseconds have passed without any new calls.
4. Use modern JavaScript (timers, etc.).
5. Export the function.
6. Return only the code for the function, no other text.
`;

/**
 * @param {string} code - The code generated by the LLM.
 * @returns {Promise<{success: boolean, message: string, details?: string}>}
 */
async function validate(code) {
  // Step 1: Check if the code is valid TypeScript and get AST.
  const tsValidation = validateTypeScript(code, { includeAst: true });
  if (!tsValidation.success || !tsValidation.ast) {
    return {
        success: tsValidation.success,
        message: tsValidation.ast ? tsValidation.message : "AST could not be generated for initial validation."
    };
  }

  // Step 2: AST Check for exported 'debounce' function
  let debounceExportFound = false;
  ts.forEachChild(tsValidation.ast, node => {
    if (ts.isFunctionDeclaration(node) && node.name && node.name.getText(tsValidation.ast) === 'debounce') {
      if (node.modifiers && node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword)) {
        debounceExportFound = true;
      }
    }
    // Check for export { debounce }
    if (ts.isExportDeclaration(node) && node.exportClause && ts.isNamedExports(node.exportClause)) {
      node.exportClause.elements.forEach(element => {
        if (element.name.getText(tsValidation.ast) === 'debounce') {
          debounceExportFound = true;
        }
      });
    }
    // Check for export default debounce (if debounce is a const or function previously defined)
    if (ts.isExportAssignment(node) && node.expression && node.expression.getText(tsValidation.ast) === 'debounce') {
        debounceExportFound = true;
    }
  });

  if (!debounceExportFound) {
    return { success: false, message: "AST check: No exported function or variable named 'debounce' found." };
  }

  // Step 3: Run Jest tests if initial TS and AST checks pass
  // __dirname for src/tests/3_createUtilFunction.js is /app/src/tests
  // Path to test file is /app/src/test-assets/debounce.test.js
  const predefinedTestFilePath = path.resolve(__dirname, "../test-assets/debounce.test.js");

  try {
    const jestResult = await runJestAgainstGeneratedCode(code, predefinedTestFilePath, false); // false for isReactCode
    return jestResult;
  } catch (error) {
    // This catch block is for unforeseen errors in runJestAgainstGeneratedCode itself,
    // though runJestAgainstGeneratedCode is designed to return a structured error object.
    console.error("Critical error calling runJestAgainstGeneratedCode:", error);
    return {
      success: false,
      message: `A critical error occurred while trying to run Jest tests: ${error.message}`,
      details: error.stack
    };
  }
}

module.exports = { id, description, prompt, validate };
