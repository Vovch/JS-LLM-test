// src/tests/10_generateStorybookStory.js
const { validateTypeScript } = require("../validators/tsValidator");
const ts = require("typescript");
const fs = require("fs/promises"); // Use promise-based fs for async/await
const path = require("path");
const { pathToFileURL } = require("url"); // Needed for dynamic import on all platforms

const id = "storybook-story-generation";
const description =
  "Generates a Storybook v7+ story file for a given React component.";

const codeToTest = `
// Button.tsx
import React from 'react';

interface ButtonProps {
  primary?: boolean;
  size?: 'small' | 'medium' | 'large';
  label: string;
}

export const Button = ({ primary = false, size = 'medium', label }: ButtonProps) => {
  return <button>{label}</button>;
};
`;

const prompt = `
You are an expert in Storybook. Your task is to create a story file for the given React 'Button' component.
You must use the modern **Storybook v7+ CSF 3.0 format**.

Requirements:
1.  The file must have a single **default export** for the component's metadata (\`Meta<typeof Button>\`).
2.  Create a **named export** for a story named 'Primary'. It should be of type \`StoryObj<typeof meta>\`.
3.  Create another **named export** for a story named 'Secondary'.
4.  The 'Primary' story should have an \`args\` property setting \`primary: true\`.
5.  Import the necessary types, \`Meta\` and \`StoryObj\`, from \`@storybook/react\`.
6.  Import the Button component from './Button'.
7.  Do not add any other text or explanations, only the pure TSX code.

Here is the component to create a story for:
${codeToTest}
`;

/**
 * @param {string} code - The code generated by the LLM.
 * @returns {Promise<{success: boolean, message: string}>}
 */
async function validate(code) {
  // Step 1: Quick syntax check. No point proceeding if it's not valid TSX.
  const tsValidation = validateTypeScript(code, { isJsx: true });
  if (!tsValidation.success) {
    return tsValidation;
  }

  // --- The New Robust Validation Method ---
  const tempDir = path.resolve(__dirname, "../../.tmp");
  // Create a unique filename to avoid import caching issues.
  const tempFileName = `test-story-${Date.now()}.mjs`;
  const tempFilePath = path.join(tempDir, tempFileName);

  try {
    // Step 2: Transpile the TSX code to modern JavaScript (ESM).
    // We replace the relative import with a placeholder that we know won't resolve,
    // as we don't actually need to run the component, just inspect the story objects.
    const codeWithPlaceholder = code.replace(
      /from ['"]\.\/Button['"]/,
      "from 'react'"
    );
    const jsCode = ts.transpileModule(codeWithPlaceholder, {
      compilerOptions: {
        module: ts.ModuleKind.ESNext, // Target ES Modules
        jsx: ts.JsxEmit.ReactJSX,
        target: ts.ScriptTarget.ESNext,
      },
    }).outputText;

    // Step 3: Write the transpiled JS to a temporary .mjs file.
    await fs.mkdir(tempDir, { recursive: true });
    await fs.writeFile(tempFilePath, jsCode);

    // Step 4: Dynamically import the module.
    // pathToFileURL is crucial for cross-platform compatibility (Windows vs. Unix).
    const storyModule = await import(pathToFileURL(tempFilePath).href);

    // Step 5: Inspect the imported module object with precision.
    if (!storyModule.default) {
      throw new Error(
        "The module does not have a default export for the story's metadata."
      );
    }
    if (typeof storyModule.default !== "object" || !storyModule.default.title) {
      throw new Error(
        "The default export is not a valid metadata object with a 'title' property."
      );
    }

    if (!storyModule.Primary) {
      throw new Error("The module is missing the named export 'Primary'.");
    }
    if (typeof storyModule.Primary !== "object") {
      throw new Error("The 'Primary' export is not an object.");
    }
    if (storyModule.Primary.args?.primary !== true) {
      throw new Error(
        "The 'Primary' story object is missing 'args: { primary: true }'."
      );
    }

    if (!storyModule.Secondary) {
      throw new Error("The module is missing the named export 'Secondary'.");
    }

    return {
      success: true,
      message: "Module successfully imported and all exports are valid.",
    };
  } catch (error) {
    // This will catch errors from the import itself (e.g., syntax errors) or our checks.
    return {
      success: false,
      message: `Validation failed during dynamic import: ${error.message}`,
    };
  } finally {
    // Step 6: Clean up the temporary file.
    try {
      await fs.unlink(tempFilePath);
    } catch {
      // Ignore errors if the file doesn't exist.
    }
  }
}

module.exports = { id, description, prompt, validate };
