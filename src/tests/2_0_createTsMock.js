// src/tests/2_createTsMock.js
const ts = require('typescript');
const { validateTypeScript } = require("../validators/tsValidator");

const id = "ts-mock-from-interface_simple";
const description =
  "Creates a mock data object from existing TypeScript interfaces.";

// The context that the LLM needs and the validator needs.
const interfaceDefinitions = `
interface Profile {
  avatarUrl?: string;
  bio?: string;
}

interface User {
  id: string;
  email: string;
  registrationDate: Date;
  profile: Profile;
}
`;

const prompt = `
Given the following TypeScript interfaces, create a single mock object named 'mockUser' of type 'User'.
Fill the fields with realistic but fake data. The 'registrationDate' should be a new Date object.
Only output the 'mockUser' constant, with no other text or explanations.

Interfaces:
${interfaceDefinitions}
`;

/**
 * @param {string} code - The code generated by the LLM.
 * @returns {{success: boolean, message: string}}
 */
async function validate(code) {
  const tsValidation = validateTypeScript(code, {
    context: interfaceDefinitions,
    includeAst: true,
  });

  if (!tsValidation.success || !tsValidation.ast) {
    return {
        success: tsValidation.success,
        message: tsValidation.ast ? tsValidation.message : "AST could not be generated."
    };
  }

  const { ast } = tsValidation;
  let mockUserFound = false;
  let correctTypeAnnotation = false;
  let idOk = false;
  let emailOk = false;
  let registrationDateOk = false;
  let profileOk = false;
  let avatarUrlOk = false;

  ts.forEachChild(ast, node => {
    if (node.kind === ts.SyntaxKind.VariableStatement) {
      ts.forEachChild(node.declarationList, varDeclaration => {
        if (varDeclaration.kind === ts.SyntaxKind.VariableDeclaration) {
          if (varDeclaration.name.getText(ast) === 'mockUser') {
            mockUserFound = true;

            if (varDeclaration.type && varDeclaration.type.typeName && varDeclaration.type.typeName.getText(ast) === 'User') {
              correctTypeAnnotation = true;
            }

            if (varDeclaration.initializer && varDeclaration.initializer.kind === ts.SyntaxKind.ObjectLiteralExpression) {
              varDeclaration.initializer.properties.forEach(prop => {
                const propName = prop.name.getText(ast);
                if (prop.kind === ts.SyntaxKind.PropertyAssignment) {
                  const initializer = prop.initializer;
                  switch (propName) {
                    case 'id':
                      if (initializer.kind === ts.SyntaxKind.StringLiteral) {
                        idOk = true;
                      }
                      break;
                    case 'email':
                      if (initializer.kind === ts.SyntaxKind.StringLiteral) {
                        // Basic check for '@' in email, could be more robust
                        if (initializer.text.includes('@')) {
                           emailOk = true;
                        }
                      }
                      break;
                    case 'registrationDate':
                      if (initializer.kind === ts.SyntaxKind.NewExpression && initializer.expression.getText(ast) === 'Date') {
                        registrationDateOk = true;
                      }
                      break;
                    case 'profile':
                      if (initializer.kind === ts.SyntaxKind.ObjectLiteralExpression) {
                        profileOk = true; // Mark profile as found
                        initializer.properties.forEach(profileProp => {
                          if (profileProp.kind === ts.SyntaxKind.PropertyAssignment && profileProp.name.getText(ast) === 'avatarUrl') {
                            if (profileProp.initializer.kind === ts.SyntaxKind.StringLiteral) {
                              avatarUrlOk = true;
                            }
                          }
                        });
                      }
                      break;
                  }
                }
              });
            }
          }
        }
      });
    }
  });

  if (!mockUserFound) {
    return { success: false, message: 'Variable "mockUser" not found.' };
  }
  if (!correctTypeAnnotation) {
    return { success: false, message: '"mockUser" is missing type annotation ": User".' };
  }
  if (!idOk) {
    return { success: false, message: 'Property "id" is missing or not a string literal.' };
  }
  if (!emailOk) {
    return { success: false, message: 'Property "email" is missing, not a string literal, or does not contain "@".' };
  }
  if (!registrationDateOk) {
    return { success: false, message: 'Property "registrationDate" is not a "new Date()".' };
  }
  if (!profileOk) { // This checks if 'profile' object itself was found
    return { success: false, message: 'Property "profile" is not an object literal.' };
  }
  if (!avatarUrlOk) { // This specifically checks for 'avatarUrl' within 'profile'
    return { success: false, message: 'Property "avatarUrl" in "profile" is missing or not a string literal.' };
  }

  return {
    success: true,
    message: "AST validation passed: mockUser object is structurally valid.",
  };
}

module.exports = { id, description, prompt, validate, interfaceDefinitions };
